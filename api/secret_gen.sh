#!/usr/bin/env bashset -euo pipefailSECRETS_DIR=./secretsGITIGNORE_FILE=./.gitignoremkdir -p "$SECRETS_DIR"umask 077new_b64_secret() {  openssl rand -base64 "$1"}# ─────────────────────────────────────────────────────────────# Basic plaintext values# ─────────────────────────────────────────────────────────────read -rp "Postgres User [pi]: " pg_userpg_user="${pg_user:-pi}"printf '%s' "$pg_user" > "$SECRETS_DIR/pg_user"read -rp "Postgres DB [app]: " pg_namepg_name="${pg_name:-app}"printf '%s' "$pg_name" > "$SECRETS_DIR/pg_name"printf '%s' "localhost" > "$SECRETS_DIR/jwt_issuer"printf '%s' "localhost" > "$SECRETS_DIR/jwt_audience"# ─────────────────────────────────────────────────────────────# Strong secrets# ─────────────────────────────────────────────────────────────read -rsp "Postgres Password (leave empty to generate): " pg_passwordechopg_password="${pg_password:-$(new_b64_secret 24)}"printf '%s' "$pg_password" > "$SECRETS_DIR/pg_password"read -rsp "Postgres DB service [db]: " pg_serviceechopg_service="${pg_service:-db}"jwt_secret="$(new_b64_secret 32)"printf '%s' "$jwt_secret" > "$SECRETS_DIR/jwt_secret"encryption_key="$(new_b64_secret 32)"printf '%s' "$encryption_key" > "$SECRETS_DIR/encryption_key"cert_password="$(new_b64_secret 16)"printf '%s' "$cert_password" > "$SECRETS_DIR/cert_password"# ─────────────────────────────────────────────────────────────# Postgres connection string# ─────────────────────────────────────────────────────────────printf '%s' \  "Host=$pg_service;Port=5432;Database=$pg_name;Username=$pg_user;Password=$pg_password" \  > "$SECRETS_DIR/pg_connection_string"  printf '%s' \  "Host=db;Port=5432;Database=$pg_name;Username=$pg_user;Password=$pg_password" \  > "$SECRETS_DIR/pg_connection_string_development"# ─────────────────────────────────────────────────────────────# Self-signed PKCS#12 certificate# ─────────────────────────────────────────────────────────────if command -v openssl >/dev/null 2>&1; then  tmp_key="$(mktemp)"  tmp_crt="$(mktemp)"  openssl req -x509 -nodes -newkey rsa:2048 \    -keyout "$tmp_key" \    -out "$tmp_crt" \    -days 365 \    -subj "/CN=localhost" \    >/dev/null 2>&1  openssl pkcs12 -export \    -inkey "$tmp_key" \    -in "$tmp_crt" \    -passout pass:"$cert_password" \    -out "$SECRETS_DIR/certificate.pfx"  rm -f "$tmp_key" "$tmp_crt"else  cat >&2 <<'WARN'openssl not found; skipping certificate generation.Place a `certificate.pfx` into `./secrets` and set `cert_password` accordingly.WARNfi# ─────────────────────────────────────────────────────────────# Permissions# ─────────────────────────────────────────────────────────────chmod 700 "$SECRETS_DIR"chmod 600 "$SECRETS_DIR"/* || true# ─────────────────────────────────────────────────────────────# .gitignore updates# ─────────────────────────────────────────────────────────────declare -a IGNORES=(  ""  ""  "### Generated by 'secret_gen.sh'"  "secret_gen.sh"  "/secrets/"  "/keys/"  "/app/certificate.pfx"  "*.pfx"  ".env"  "/bin/"  "/obj/"  "/out/"  "### End of generated entries")if [ ! -f "$GITIGNORE_FILE" ]; then  touch "$GITIGNORE_FILE"  chmod 600 "$GITIGNORE_FILE" || truefifor entry in "${IGNORES[@]}"; do  if ! grep -Fxq -- "$entry" "$GITIGNORE_FILE"; then    printf '%s\n' "$entry" >> "$GITIGNORE_FILE"  fidoneprintf 'Secrets written to ./secrets and .gitignore updated (do not commit secrets).\n'# End of secret_gen.sh# Kubernetes secrets generation:#kubectl create secret generic api-secrets \#  --namespace api-rubenflinterman-com \#  --from-file=certificate.pfx=./secrets/certificate.pfx \#  --from-file=cert_password=./secrets/cert_password \#  --from-file=encryption_key=./secrets/encryption_key \#  --from-file=jwt_secret=./secrets/jwt_secret \#  --from-file=jwt_issuer=./secrets/jwt_issuer \#  --from-file=jwt_audience=./secrets/jwt_audience \#  --from-file=pg_connection_string=./secrets/pg_connection_string